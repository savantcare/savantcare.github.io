(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{262:function(e,t,n){"use strict";n.r(t);var a=n(6),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"q1-should-row-start-and-row-end-be-string-or-numnber"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#q1-should-row-start-and-row-end-be-string-or-numnber"}},[e._v("#")]),e._v(" Q1) Should ROW_START and ROW_END be string or numnber?")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    vuex-orm does not have a native type called Date. The native data types are at: https://vuex-orm.org/guide/model/defining-models.html#generic-type\n       + ves of storing as a number:\n         1.  When using data\n                At a lot of places in the code I will need to compare the current time with ROW_END\n                For e.g. 1. To decide if the row is discontinued.\n                       2. For a previous appt to decide if the row was discontinued before that appt time.\n         2. Whhen reading data\n              MariaDB is already storing the ROW_START and ROW_END as numbers.\n         3. When saving data\n              I can again use numbers. No need to change from string to numbers.\n")])])]),n("h1",{attrs:{id:"q2-on-the-client-side-should-i-work-with-seconds-or-microseconds"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#q2-on-the-client-side-should-i-work-with-seconds-or-microseconds"}},[e._v("#")]),e._v(" Q2) On the client side should I work with seconds or microseconds?")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("      ROW_START and ROW_END are stored as timestamp(6). This mneans there is 6 digits of precision hence in microseconds\n          Ref: https://mariadb.com/kb/en/timestamp/ and\n          https://mariadb.com/kb/en/temporal-data-tables/\n\n       Goal is to do monimum number of conversions. Hence we will store the data the way it is given to us.\n")])])]),n("h1",{attrs:{id:"q3-what-should-be-the-primary-key"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#q3-what-should-be-the-primary-key"}},[e._v("#")]),e._v(" Q3) What should be the primary key?")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" Option1: uuid -> Not possible since there are duplicate uuid as this is temporal DB\n                  if there are 10 data rows and 2 are duplicate then entities will only get 8 entries.\n\n Option2: composite primary key.\n        ['uuid', 'ROW_START'] // Ref: https://vuex-orm.org/guide/model/defining-models.html#primary-key\n\n        Finding data from primary key is much faster then finding data by running a loop over all the data rows.\n\n        Update with primary key:\n             ormRem.update({\n              where: uniqueRowID              // vuex-orm knows that it needs to match with primary key\n              data: {\n                remDesc: pEvent,\n                },\n              })\n\n\n        update with composite primary ley:\n         ormRem.update({\n          where: [remUUID, this.reminderRowStart],    // The index is bigger and it will take longer to match\n          data: {\n            remDesc: pEvent,\n            },\n          })\n\n\n Option3: Let vuex-orm give auto generated string primary key of auto increment numbers like $uid1\n\n Option 4: Generate a numerical ID\n Better performance. Ref: https://stackoverflow.com/questions/10639488/faster-to-access-numeric-property-by-string-or-integer\n\n\n Choice made in July 2020: Option 4\n")])])]),n("h1",{attrs:{id:"q4-how-to-give-numeric-id-to-each-row"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#q4-how-to-give-numeric-id-to-each-row"}},[e._v("#")]),e._v(" Q4) How to give numeric ID to each row ?")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  Solution comes from cue on slack given on 10th July 2020\n    The closure passed into this.uid(() => intUniqueID()) simply invokes the closure when the model is instructed to generate a uid. The callback simply needs to return a value.\n    In it’s simplest form, all you need for a primitive value is:\n    let count = 0\n    const intUniqueID = () => ++count\n    this.uid(() => intUniqueID())\n")])])])])}),[],!1,null,null,null);t.default=i.exports}}]);